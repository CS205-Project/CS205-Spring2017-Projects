<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CS205 Spring 2017 Project: Parallel MCMC</title>
    <link href="/cs205-project/assets/css/style.css?v=068ad4ab58ecfbf6e07b1f15a08b9e90f5296d3e" rel="stylesheet">
  </head>
  <body>
    <div class="container markdown-body">
      <h1 id="cs205-spring-2017-project-parallel-mcmc">CS205 Spring 2017 Project: Evacuation Strategy</h1>

<p>Sonu Mehta, Tomas Gudmundsson, Dali Moghimi</p>

<h2 id="background">Project Description(Problem Statement)</h2>

<p>

The goal of the project is to find exit selections for evacuees in an emergency situation such that each person is directed to one of the nearest exits taking into account the congestion of the exit. To describe in detail, we start with a floor plan of a building. This plan is converted to a graph with nodes equal to the sum of number of persons and exits available. The graph is connected graph with edge weights representing the distance between two nodes. In case of an emergency evacuation, the goal is to assign each person their nearest exit but at the same time, taking into account there is no congestion at exits. Each exit has its own capacity to safely evacuate persons. The algorithm is expected to output the best or (near to best) assignment of evacuees to exits such that the cost is minimized. The cost , in this problem is defined as the sum of the distances of each person from their assigned exit and the penalty added for congestion at each exit.</p>

      <h2 id="algorithm">Algorithm</h2>
<p>We start with an adjacent matrix of the graph representing the floor plan of a building. This graph is randomly generated connected weighted graph with few random nodes assigned as exits. For each exit, we use Dijkstra algorithm to find the shortest distances to each node(representing a person). Once we have the distance to each exit for every person, we assign the nearest exit to each person and calculate the cost of the assignment. While calculating the cost,for now, we assume that the congestion can only be at exits and not at edges , i.e., any number of persons can pass through an edge at a given point of time.

Once we have this assignment, we use simulated annealing to find the min. cost configuration. We start with a high temperature and each iteration, we generate a new configuration by changing the exit assignment of one the persons at random. If the new assignment has lower cost that the older assignment, we accept the configuration and if the cost is higher , we accept the new configuration with probability $= exp((newCost - oldCost))/T$ where $T$ is the temperature. We continue this for a certain number of iterations after which the temperature is reduced to $0.8T$. Ultimately the algorithm settles at the low-cost configuration.</p>
<h2 id="parallel">Parallel implementation</h2>
<p>The above algorithm is sequential and calculates the shorted distance using Dijkstra one by one. Since Dijkstra from one exit is not affected by another exit, we parallelize the algorithm by using openmp to calculate the shortest distance from all exits in parallel. This speeds up the process of calculation of shortest distance. Similarly, for simulated annealing, instead of starting with 1 initial configuration, we start with multiple initial configurations in parallel and take the best solution at the end.

Preliminary results: The following plot shows how long the sequential algorithm took to calculate shortest paths for everyone and apply the simulated annealing technique for graphs of sizes 500, 5000, and 10000 (i.e. the number of people that are evacuated):

alt tag</p>

<p><img src=" CS205-Spring2017-Projects/sequentialEvacuationTime.png
" alt="evacuation time" /></p>

      <h2 id="next">Next steps</h2>
      <p>We have the basic version of evacuation algorithm working which is expected to nd the best (or near to best
solution) using simulated annealing.
Going ahead with the project, we would like to compare the implementation of Dijkstra with All Pair Shortest
Paths(in parallel) and make comparisons for the two algorithms. If time permits, we would like to add additional
constraints to make the problem complex, like adding edge capacities, taking dierent speeds of walking for
each person etc.
      </p>
    </div>
  </body>
</html>
